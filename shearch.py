#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
shearch.py - B√∫squeda y optimizaci√≥n de par√°metros para estrategia de opciones binarias
"""

import backtrader as bt
import pandas as pd
import numpy as np
import itertools
from collections import defaultdict
import os
from datetime import datetime
import json
import random  # Importar random al inicio

# Importar componentes de default.py
from default import (
    BinaryOptionsStrategy, 
    BinaryOptionsAnalyzer, 
    load_data,
    run_single_backtest
)

class ParameterOptimizer:
    """Clase para optimizaci√≥n de par√°metros"""
    
    def __init__(self, data_feed):
        self.data_feed = data_feed
        self.results = []
        self.best_result = None
        
    def define_parameter_ranges(self):
        """Definir rangos de par√°metros para optimizar"""
        param_ranges = {
            'ema1_period': [5, 8, 13, 21],
            'st_period': [7, 10, 14, 21],
            'st_multiplier': [2.0, 2.5, 3.0, 3.5, 4.0],
            'adx_period': [14, 21],
            'adx_threshold': [20, 25, 30],
            'rsi_period': [14, 21],
            'rsi_oversold': [30, 35],
            'rsi_overbought': [65, 70],
            'supertrend_delay_bars': [3, 4, 5],
            'expiry_minutes': [15, 30, 45, 60, 90, 120],
            'max_trades_per_day': [8, 12, 16],
            'min_time_between_trades': [3, 5, 8],
        }
        
        return param_ranges
    
    def generate_parameter_combinations(self, max_combinations=100, use_random_seed=True):
        """Generar combinaciones de par√°metros (limitado para evitar explosi√≥n combinatoria)"""
        param_ranges = self.define_parameter_ranges()
        
        # Calcular total de combinaciones posibles
        total_combinations = 1
        for values in param_ranges.values():
            total_combinations *= len(values)
        
        print(f"üìä Total de combinaciones posibles: {total_combinations:,}")
        
        if total_combinations <= max_combinations:
            # Si son pocas, usar todas las combinaciones
            print(f"‚úÖ Usando todas las {total_combinations} combinaciones disponibles")
            keys = list(param_ranges.keys())
            values = list(param_ranges.values())
            combinations = list(itertools.product(*values))
            
            param_sets = []
            for combo in combinations:
                param_set = {}
                for key, value in zip(keys, combo):
                    # Convertir a tipos Python nativos
                    if isinstance(value, (np.integer, np.int64, np.int32)):
                        param_set[key] = int(value)
                    elif isinstance(value, (np.floating, np.float64, np.float32)):
                        param_set[key] = float(value)
                    else:
                        param_set[key] = value
                param_sets.append(param_set)
                
        else:
            # Si son muchas, usar muestreo aleatorio
            print(f"üé≤ Usando muestreo aleatorio de {max_combinations} combinaciones")
            param_sets = []
            
            # CORRECCI√ìN PRINCIPAL: Inicializar semilla aleatoria UNA SOLA VEZ
            # y usar un timestamp o None para hacerlo verdaderamente aleatorio
            if use_random_seed:
                # Usar timestamp para semilla √∫nica cada vez que se ejecuta
                seed = int(datetime.now().timestamp() * 1000) % 2**32
                random.seed(seed)
                np.random.seed(seed)
                print(f"üîë Usando semilla aleatoria: {seed}")
            else:
                # Para pruebas reproducibles
                random.seed(42)
                np.random.seed(42)
                print(f"üîë Usando semilla fija: 42")
            
            # Generar todas las combinaciones posibles primero
            keys = list(param_ranges.keys())
            values = list(param_ranges.values())
            all_combinations = list(itertools.product(*values))
            
            # Seleccionar aleatoriamente sin repetici√≥n
            if len(all_combinations) > max_combinations:
                selected_indices = random.sample(range(len(all_combinations)), max_combinations)
                selected_combinations = [all_combinations[i] for i in selected_indices]
            else:
                selected_combinations = all_combinations
            
            # Convertir a diccionarios de par√°metros
            for combo in selected_combinations:
                param_set = {}
                for key, value in zip(keys, combo):
                    # Convertir a tipos Python nativos
                    if isinstance(value, (np.integer, np.int64, np.int32)):
                        param_set[key] = int(value)
                    elif isinstance(value, (np.floating, np.float64, np.float32)):
                        param_set[key] = float(value)
                    else:
                        param_set[key] = value
                param_sets.append(param_set)
            
            print(f"‚úÖ Generadas {len(param_sets)} combinaciones √∫nicas")
        
        return param_sets
    
    def format_result_summary(self, result):
        """Formatear un resumen limpio del resultado"""
        if not result or not isinstance(result, dict):
            return "Resultado inv√°lido"
        
        return (f"Trades: {result.get('total_trades', 0)} | "
                f"Win Rate: {result.get('win_rate', 0):.1f}% | "
                f"P&L: ${result.get('total_pnl', 0):.2f}")
    
    def run_optimization(self, max_combinations=50, min_trades=10, verbose=False, use_random_seed=True):
        """Ejecutar optimizaci√≥n de par√°metros"""
        print("\n" + "="*60)
        print("üîç INICIANDO OPTIMIZACI√ìN DE PAR√ÅMETROS")
        print("="*60)
        
        # Generar combinaciones con opci√≥n de semilla aleatoria
        param_sets = self.generate_parameter_combinations(max_combinations, use_random_seed)
        total_sets = len(param_sets)
        
        # Verificar que realmente tenemos combinaciones
        if total_sets == 0:
            print("‚ùå No se pudieron generar combinaciones de par√°metros")
            return
        
        print(f"üß™ Probando {total_sets} combinaciones de par√°metros...")
        print(f"üìà M√≠nimo de trades requeridos: {min_trades}")
        
        # Ejecutar backtests
        valid_results = 0
        error_count = 0
        
        # Para mostrar progreso cada 10%
        progress_points = [max(1, int(total_sets * p / 10)) for p in range(1, 11)]
        
        for i, params in enumerate(param_sets):
            try:
                # Mostrar progreso solo en ciertos puntos
                if (i + 1) in progress_points or i == 0:
                    progress = ((i + 1) / total_sets) * 100
                    print(f"‚ö° Progreso: {progress:.0f}% - V√°lidos: {valid_results}/{i+1}")
                
                # Debug detallado solo si verbose=True y para las primeras 3 combinaciones
                if verbose and i < 3:
                    print(f"\nüîß Probando combinaci√≥n {i+1}:")
                    for key, value in params.items():
                        print(f"   {key}: {value}")
                
                # Ejecutar backtest
                result = run_single_backtest(self.data_feed, **params)
                
                # Debug del resultado solo si verbose=True
                if verbose and i < 3:
                    print(f"üìä Resultado: {self.format_result_summary(result)}")
                
                # Validar resultado
                if result and isinstance(result, dict):
                    total_trades = result.get('total_trades', 0)
                    if total_trades >= min_trades:
                        # Limpiar el resultado antes de guardarlo (eliminar lista de trades)
                        clean_result = {k: v for k, v in result.items() if k != 'trades'}
                        clean_result['parameters'] = params.copy()
                        clean_result['combination_id'] = i + 1
                        self.results.append(clean_result)
                        valid_results += 1
                        
                        if verbose and i < 3:
                            print(f"‚úÖ Combinaci√≥n {i+1} v√°lida: {total_trades} trades")
                    else:
                        if verbose and i < 3:
                            print(f"‚ùå Combinaci√≥n {i+1} rechazada: solo {total_trades} trades (m√≠nimo {min_trades})")
                else:
                    error_count += 1
                    if verbose and i < 3:
                        print(f"‚ùå Combinaci√≥n {i+1} fall√≥: resultado nulo o inv√°lido")
                
            except Exception as e:
                error_count += 1
                if verbose and i < 3:
                    print(f"‚ùå Error en combinaci√≥n {i+1}: {str(e)}")
                continue
        
        # Progreso final
        print(f"‚ö° Progreso: 100% - V√°lidos: {valid_results}/{total_sets}")
        
        print(f"\n‚úÖ Optimizaci√≥n completada!")
        print(f"üìä Combinaciones v√°lidas: {valid_results}/{total_sets}")
        if error_count > 0:
            print(f"‚ö†Ô∏è Errores encontrados: {error_count}")
        
        if valid_results > 0:
            self.analyze_results()
        else:
            print("‚ùå No se obtuvieron resultados v√°lidos")
            print("\nüîç DIAGN√ìSTICO:")
            print("- Verifica que los par√°metros generen se√±ales de trading")
            print("- Reduce el m√≠nimo de trades requeridos")
            print("- Aumenta el n√∫mero de combinaciones a probar")
            print("- Revisa que los datos tengan suficiente historia")
    
    def analyze_results(self):
        """Analizar y mostrar los mejores resultados"""
        if not self.results:
            print("‚ùå No hay resultados para analizar")
            return
        
        # Ordenar por diferentes m√©tricas
        by_winrate = sorted(self.results, key=lambda x: x['win_rate'], reverse=True)
        by_pnl = sorted(self.results, key=lambda x: x['total_pnl'], reverse=True)
        by_profit_factor = sorted(self.results, key=lambda x: x['profit_factor'], reverse=True)
        by_trades = sorted(self.results, key=lambda x: x['total_trades'], reverse=True)
        
        # Criterio: Mejor P&L Total (m√°s rentable)
        self.best_result = by_pnl[0]  # La configuraci√≥n m√°s rentable
        print(f"üéØ Criterio: Mayor P&L Total (M√°s Rentable)")
        
        print("\n" + "="*80)
        print("üèÜ TOP 5 RESULTADOS POR DIFERENTES M√âTRICAS")
        print("="*80)
        
        # Top 5 por Win Rate
        print(f"\nüìä TOP 5 POR WIN RATE:")
        print("-" * 60)
        for i, result in enumerate(by_winrate[:5]):
            print(f"{i+1}. Win Rate: {result['win_rate']:.1f}% | "
                  f"P&L: ${result['total_pnl']:.2f} | "
                  f"Trades: {result['total_trades']} | "
                  f"ID: {result['combination_id']}")
        
        # Top 5 por P&L Total
        print(f"\nüí∞ TOP 5 POR P&L TOTAL:")
        print("-" * 60)
        for i, result in enumerate(by_pnl[:5]):
            print(f"{i+1}. P&L: ${result['total_pnl']:.2f} | "
                  f"Win Rate: {result['win_rate']:.1f}% | "
                  f"Trades: {result['total_trades']} | "
                  f"ID: {result['combination_id']}")
        
        # Top 5 por Profit Factor
        print(f"\n‚öñÔ∏è TOP 5 POR PROFIT FACTOR:")
        print("-" * 60)
        for i, result in enumerate(by_profit_factor[:5]):
            pf = result['profit_factor']
            pf_str = f"{pf:.2f}" if pf != float('inf') else "‚àû"
            print(f"{i+1}. Profit Factor: {pf_str} | "
                  f"P&L: ${result['total_pnl']:.2f} | "
                  f"Win Rate: {result['win_rate']:.1f}% | "
                  f"ID: {result['combination_id']}")
        
        # Mostrar el mejor resultado en detalle
        print("\n" + "="*80)
        print("ü•á MEJOR CONFIGURACI√ìN (Por P&L Total)")
        print("="*80)
        self.show_detailed_result(self.best_result)
    
    def show_detailed_result(self, result):
        """Mostrar resultado detallado"""
        if not result:
            return
        
        print(f"\nüìà M√âTRICAS DE RENDIMIENTO:")
        print(f"   üí∞ P&L Total: ${result['total_pnl']:.2f}")
        print(f"   üéØ Win Rate: {result['win_rate']:.1f}%")
        print(f"   üìä Total Trades: {result['total_trades']}")
        print(f"   ‚úÖ Trades Ganadores: {result['winning_trades']}")
        print(f"   ‚ùå Trades Perdedores: {result['losing_trades']}")
        print(f"   üìâ P&L Promedio: ${result['avg_pnl_per_trade']:.2f}")
        
        pf = result['profit_factor']
        pf_str = f"{pf:.2f}" if pf != float('inf') else "‚àû"
        print(f"   ‚öñÔ∏è Profit Factor: {pf_str}")
        
        print(f"\nüîß PAR√ÅMETROS √ìPTIMOS:")
        params = result['parameters']
        
        print(f"   üìä EMA Period: {params['ema1_period']}")
        print(f"   üåü SuperTrend Period: {params['st_period']}")
        print(f"   üåü SuperTrend Multiplier: {params['st_multiplier']}")
        print(f"   üåü SuperTrend Delay Bars: {params['supertrend_delay_bars']}")
        print(f"   üìà ADX Period: {params['adx_period']}")
        print(f"   üìà ADX Threshold: {params['adx_threshold']}")
        print(f"   üîÑ RSI Period: {params['rsi_period']}")
        print(f"   üîÑ RSI Oversold: {params['rsi_oversold']}")
        print(f"   üîÑ RSI Overbought: {params['rsi_overbought']}")
        print(f"   ‚è∞ Expiry Minutes: {params['expiry_minutes']}")
        print(f"   üõ°Ô∏è Max Trades/Day: {params['max_trades_per_day']}")
        print(f"   ‚è≥ Min Time Between Trades: {params['min_time_between_trades']} min")
    
    def save_results(self, filename=None):
        """Guardar resultados en archivo JSON con nombre √∫nico"""
        if not self.results:
            print("‚ùå No hay resultados para guardar")
            return
        
        try:
            # Generar nombre de archivo √∫nico si no se proporciona
            if filename is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"optimization_results_{timestamp}.json"
            
            # Preparar datos para guardar
            save_data = {
                'optimization_date': datetime.now().isoformat(),
                'total_combinations_tested': len(self.results),
                'best_result': self.best_result,
                'all_results': self.results[:20]  # Solo los primeros 20 para no hacer el archivo muy grande
            }
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(save_data, f, indent=2, ensure_ascii=False, default=str)
            
            print(f"üíæ Resultados guardados en: {filename}")
            
        except Exception as e:
            print(f"‚ùå Error guardando resultados: {e}")

def run_parameter_search(verbose=False):
    """Funci√≥n principal para b√∫squeda de par√°metros"""
    print("üîç B√öSQUEDA Y OPTIMIZACI√ìN DE PAR√ÅMETROS")
    print("=" * 50)
    
    # 1. Buscar archivo de datos
    possible_files = ["EURUSD5.csv"]
    
    data_file = None
    for filename in possible_files:
        if os.path.exists(filename):
            data_file = filename
            break
    
    if not data_file:
        print("‚ùå No se encontr√≥ archivo de datos. Ejecuta primero 'data_downloader.py'")
        return
    
    print(f"üìÇ Usando archivo: {data_file}")
    
    # 2. Cargar datos
    data_feed = load_data(data_file)
    if data_feed is None:
        return
    
    # 3. Configurar optimizaci√≥n
    print(f"\nüéõÔ∏è CONFIGURACI√ìN DE LA OPTIMIZACI√ìN:")
    
    try:
        max_combinations = int(input("üß™ M√°ximo de combinaciones a probar (por defecto 20): ") or 20)
        min_trades = int(input("üìà M√≠nimo de trades requeridos (por defecto 5): ") or 5)
        
        # Preguntar si quiere modo verbose
        verbose_input = input("üîç ¬øMostrar informaci√≥n detallada de debug? (y/N): ").strip().lower()
        verbose = verbose_input in ['y', 'yes', 's√≠', 'si']
        
        # NUEVA OPCI√ìN: Preguntar si quiere resultados aleatorios o reproducibles
        random_input = input("üé≤ ¬øUsar selecci√≥n aleatoria de par√°metros? (Y/n): ").strip().lower()
        use_random = random_input not in ['n', 'no']
        
        if not use_random:
            print("üîí Usando selecci√≥n fija (reproducible)")
        else:
            print("üé≤ Usando selecci√≥n aleatoria (resultados diferentes cada vez)")
        
    except ValueError:
        max_combinations = 20
        min_trades = 5
        verbose = False
        use_random = True
        print("‚ö†Ô∏è Usando valores por defecto")
    
    # 4. Ejecutar optimizaci√≥n
    optimizer = ParameterOptimizer(data_feed)
    optimizer.run_optimization(max_combinations=max_combinations, 
                             min_trades=min_trades, 
                             verbose=verbose,
                             use_random_seed=use_random)
    
    # 5. Guardar resultados
    if optimizer.results:
        save_choice = input(f"\nüíæ ¬øGuardar resultados en archivo? (y/N): ").strip().lower()
        if save_choice in ['y', 'yes', 's√≠', 'si']:
            optimizer.save_results()
    
    return optimizer

def main():
    """Funci√≥n principal del m√≥dulo"""
    run_parameter_search()

if __name__ == "__main__":
    main()